## 1.1 编译原理

作用域：一套存储变量（标识符）的规则，并以后可以很方便地找到这些变量，确定当前执行的代码对标识符的访问权限

存储和访问变量的值的能力将状态带给了程序

js是编译语言
1. 分词和词法分析（Tokenizing / Lexing）
    
    将字符串分解成有意义的代码块，代码块被称为词法单元（token）
    
    例：var a = 2; 被分解成 var a = 2 ; 5个token
    
    分词：无状态

    词法分析：有状态

2. 解析/语法分析（Parsing）

    将词法单元流（数组）[ 上述1中的词法单元数组（tokens） ]转化为由元素逐级嵌套的代表程序语法结构的树（抽象语法树 AST）

3. 代码生成

    将AST转化为可执行代码，转化为一组机器指令

js在运行前进行编译

## 1.2 理解作用域

1. 引擎 从头到尾负责整个js的编译和执行
2. 编译器 负责语法分析和代码生成等
3. 作用域

var a = 2 ，编译器会进行如下处理

1. 编译时进行变量的声明
2. 运行时进行变量的赋值

1. LHS 找到变量的容器本身
2. RHS 查找变量的值

> 函数声明 function foo(a){ ... }
>
> 跟一般变量的“编译时声明、运行时赋值”不同，函数声明会在代码生成的同时进行声明和值的定义

作用域嵌套

在当前作用域无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止

## 1.3 异常

在变量还未声明，在任何作用域都无法找到该变量时，这两种查询的行为是不一样的。

如果RHS找不到变量，则引擎会抛出一个ReferenceError异常


非“严格模式”下，如果LHS找不到变量，则会在全局作用域中创建一个

“严格模式”下，引擎抛出ReferenceError异常

如果RHS查询到一个变量，但你尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，或者引用null或者undefined类型的值中的属性，那么引擎就会抛出另外一种类型的异常，叫做TypeError

TypeError代表作用域判别成功了，但是对结果的操作是非法或者不合理的

